Лаба 1
Вариант 3
Цель работы: Разработка и реализация программы для вычисления расстояния Хэмминга между двумя строками (число позиций, в которых эти две строки различаются), представляющими последовательности ДНК.
Задачи: 
1. Написать функцию, которая принимает две строки одинаковой длины в качестве аргументов и возвращает расстояние Хэмминга между ними. 
2. Обработать исключение, если длины входных строк различны.
3. Проверить корректность работы функции на тестовом примере.
Ход работы:
Программа начинается с создания функции hamming_distance, которая принимает две строки - s и t, в качестве входных параметров.
1. Проверка на равенство длин строк: сначала функция проверяет, равны ли длины строк s и t. Это важно, так как расстояние Хэмминга определяется только для строк одинаковой длины.  Если длины различны, возвращается -1.
2. Если длины строк равны, выполняется вычисление.  Выражение sum(a != b for a, b in zip(s, t)) является ядром алгоритма. 
zip(s, t): Функция zip  создает итератор, который возвращает кортежи из пар символов, взятых из строк s и t с одинаковыми индексами. Например, для первых нескольких символов s и t  zip(s, t)  будет генерировать: ('G', 'C'), ('A', 'A'), ('G', 'T'), и так далее.
(a != b for a, b in zip(s, t)): Это генератор списка, который перебирает кортежи, полученные от zip. Для каждого кортежа (a, b) он проверяет, равны ли символы a и b. Результатом является итератор, содержащие значения - True если символы разные, False если одинаковые.
sum(...): Функция sum суммирует все значения в итераторе. Python интерпретирует True как 1 и False как 0.  Таким образом, sum() подсчитывает количество пар символов, которые различны, что и является расстоянием Хэмминга.
3. Вызов функции и вывод результата: в две переменные записывается информация о двух строках с нуклеотидами ДНК. Результат функции hamming_distance (s, t) записывается в переменную distance, и затем выводится на экран функцией print().
Алгоритм: прямой подсчёт различий между символами на соответствующих позициях двух строк. Используется итеративный подход с помощью zip() и генератора списка. 
Структуры данных: Строки (str).
Ошибки: 
1. В первоначальном виде кода не была учтена важность равенства длины строк.
2. Неэффективная обработка: Замена sum(s[i] != t[i] for i in range(len(s))) на  sum(a != b for a, b in zip(s, t)). Использование цикла for и индексации  s[i] и t[i]  менее эффективно, чем использование zip в улучшенном варианте кода.  Для длинных строк (размером 1 килобазы, т.е. близких к 1000 символов),  zip работает быстрее.
Выводы: Полученный код правильно и эффективно вычисляет расстояние Хэмминга между двумя строками ДНК. Алгоритм имеет линейную временную сложность O(n), где n - длина строк, что делает его достаточно эффективным для строк длиной до одной килобазы.
