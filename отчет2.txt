Лаба 2 
Вариант 5
Цель работы: Разработать программу на, которая находит все позиции вхождения подстроки t в строке s.
Задачи:
1.  Создать программу, которая считывает две строки, s и t, с пользовательского ввода.
2.  Найти все непересекающиеся вхождения подстроки t в строке s.
3.  Вывести список позиций, где начинается каждое вхождение подстроки в строку (индексы начинаются с 0).
Ход работы:
Программа состоит из функции main().
1.  Ввод данных: Строки s и t с помощью функции input() вводятся пользователем с клавиатуры: сначала исходная строка s, а затем подстрока t.
2.  Ключевым элементом программы является list comprehension - это компактный способ создания списков:
positions = [i for i in range(len(s) - len(t) + 1) if s[i:i + len(t)] == t]
range(len(s) - len(t) + 1): Эта часть генерирует последовательность целых чисел от 0 до len(s) - len(t), включительно. Каждое число в этой последовательности представляет собой потенциальный начальный индекс подстроки t внутри строки s. Мы вычитаем len(t) из len(s) и добавляем 1, чтобы убедиться, что цикл перебирает все возможные начальные позиции, при которых t полностью помещается в s.
s[i:i + len(t)] == t: Для каждого индекса i, сгенерированного range(), из строки s извлекается подстрока длиной len(t), начинающаяся с этого индекса. Затем эта подстрока сравнивается с подстрокой t.
 [i for ... if ...]: создаётся список positions. В этот список включаются только те индексы i, для которых условие s[i:i + len(t)] == t истинно, то есть только те индексы, с которых начинается подстрока t внутри строки s.
3.  Вывод результатов: Список positions, содержащий начальные индексы всех вхождений подстроки t в строке s, выводится на консоль с помощью функции print(positions). Индексы, выводимые программой, начинаются с 0.
Алгоритм: линейный поиск подстроки с использованием срезов строк и list comprehension.
Структуры данных: Строки, списки.
Ошибки: 
1.	Некорректная обработка случая, когда подстрока t длиннее строки s, исходный код не проверял на это условие. Возвращался пустой список, что может быть интерпретировано как отсутствие совпадений, но на самом деле это ошибка ввода.
2.	Неэффективность для очень больших строк. Более эффективные алгоритмы поиска подстрок (Бойера-Мура, Кнута-Морриса-Пратта) значительно улучшат производительность в таких случаях, но изначальный алгоритм был оставлен из-за сложности упомянутых алгоритмов.
Выводы:
Программа решает поставленную задачу, находя все вхождения подстроки t в строке s и выводя их начальные индексы. Использование list comprehension делает код достаточно компактным и читаемым. Алгоритм имеет временную сложность O(m*n), где n - длина строки s, а m - длина строки t.
